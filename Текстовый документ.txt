Добрый день!
Задание решено верно.
С уважением,
Кирилл.


Добрый день!
Вы не исправили предыдущие замечания. Обратите внимание на скриншот в начале условия, у вас нет папок routers, models и backdend соответственно. Также много недостающих файлов. если сейчас не исправить, то структура последующих заданий тоже будет не верной.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. У вас нет папки versions внутри папки migrations, в этой папке должны храниться все варианты миграций базы данных. У вас данной папки нет, это говорит о том, что вы не создавали миграции и не прогоняли их, чтобы они применились и таблицы появились в базе данных.
С уважением,
Кирилл.


Добрый день!
Прошу выгрузить задание не в виде архива, а полноценного проекта с соблюдением структуры. GitHub позволяет делать это.
С уважением,
Кирилл.


Добрый день!
Откройте пожалуйста доступ к коллабу.
С уважением,
Кирилл.


Добрый день!
Решение не полное, задания выполнены только из 1 google collab.
С уважением,
Кирилл.


Добрый день!
Задание решено не верно. Посмотрел ваш файл миграции, он не генерирует таблицы, ошибки импортов в env.py, и не настроена target_metadata. Alembic не видит таблицы, которые вы создаете с помощью sqlalchemy и не генерирует их в базе.
С уважением,
Кирилл.


Добрый день!
Задание решено не верно. Структура проекта не соответствует условию (посмотрите скрин в начале задачи). Также нет папки alembic или migrations со всеми вытекающими настройками, и самого файла миграции, который вы должны были генерировать.
С уважением,
Кирилл.


Добрый день!
Задание решено не верно. Структура проекта не соответсвует той, которая указано на скриншоте в условии, также не вижу у вас папки migrations и файла миграции, которые должны были инициализироваться после успешной настройки alembic.
С уважением,
Кирилл.


Добрый день!
Задание решено верно. Для того, чтобы вам не приходилось указывать параметр extend_existing, не нужно будет вызывать CreateTable каждой модели, достаточно просто указать base.metadata в env.py. В данном случае, вам нужно было распечатать SQL запросы, поэтому в целом такое использование допустимо.
С уважением,
Кирилл.


Добрый день!
Задание решено не верно. Задачей является организовать структура проекта, как указано на скриншоте в условии, а не в одной корневой директории проекта.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. В условии задания указано, что задержка должна быть  обратно пропорциональной его силе power, что означает 1/power.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. В вашей реализации получается так, что вне зависимости от того какой id у последнего пользователя, новый id нового пользователя всегда будет равен длине списка + 1, но это не совсем верно. Задача сделать так, чтобы id был именно на 1 больше чем у предыдущего. В ситуации, в которой мы добавили пользователей, а потом удалили например того, кто был по середине, в таком случае id нового пользователя будет равен id последнего пользователя в списке.
С уважением,
Кирилл.


Добрый день!
Задание решено не верно. Методы post и put, не должны получать username и т.д, как параметры запроса. Параметр должен быть один user с аннотацией типа pydantic модели User.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. Осталось только изменить то, что возвращают методы update и delete, они долджны возвращать обновленный или удаленный объект класса User соответственно.
С уважением,
Кирилл.



Добрый день!
Задание решено верно. По поводу индекса нового пользователя, можно было не применять функцию max и не проходиться циклом по списку пользователей, можно просто проверить пуст ли список и если не пуст, обратиться к последнем элементу списка через индекс -1, взять его id и уже к нему прибавить 1.
С уважением,
Кирилл.


Добрый день!
Задание решено не верно. Условие задания не выполнено, вы не используете конструкцию try except, вашей задачей является попробовать отловить ошибку TypeError.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно, но ожидается, что вы будете правильно использовать вызовы методов __init__ родительских классов, в классе наследнике.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. Ошибка в том, что вы напрямую переопределяете строку, которая выведется при методе voice, этого не нужно делать, необходимо сделать так, что при множественном наследовании, отрабатывала именно строка из класса Eagle.
С уважением,
Кирилл.


Добрый день!
Задание решено неверно. Атрибуты alive, fed, adible должны принадлежать классам. Метод eat должен инициализироваться только в одном классе Animal, не нужно переопределять его в классе Mammal и Predator. Задание заключается в использовании наследования, если вы переопределяете два одинаковых метода в дочерних классах, то нет никакого смысла в наследовании.
С уважением,
Кирилл.


Добрый день!
Задание решено неверно. Ваши классы не имеют init методов, что не соответствует условию задачи. У каждого объекта класса должны быть атрибуты, которые как раз инициализируются посредством метода init. Рекомендую еще раз ознакомиться с условием задачи.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. Метод add должен возвращать не новое количество этажей, а новый объект с обновленными аттрибутами.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. Ваш декоратор должен возвращать результат работы функции, а строки простое и составное просто печатать.
С уважением,
Кирилл.


Добрый день!
Задание решено не верно. Проверка на простоту не является правильной, вам нужно проверить делится ли ваше число на одно из диапазона от 2 до вашего числа - 1. Во втором модуле была подобная задача.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. Из за того что переменная total_enemies принадлежит классу, а не объекту, для обоих рыцарей общее число противников, что не соответствует условию задачи.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. Но в случае, если подать силу рыцаря не кратную 100, то в таком случае у вас будет вечный цикл, так как условие (количество врагов равно 0) никогда не выполнится.
С уважением,
Кирилл.


Добрый день!
Прошу отправить ссылку на выгруженное в гитхаб репозиторий решение для более корректной проверки.
С уважением,
Кирилл.


Добрый день!
Задание решено практически верно. В условии к заданию было указано, что необходимо также в программе использовать оператор continue, поэтому прошу доработать код.
С уважением,
Кирилл.



Добрый день!
Задание решено не верно. Нужно чтобы, root_word встречалось в словах из other_words, в не наоборот, как у вас. Также у вас не учтено, что слова могут быть в разных регистрах.
С уважением,
Кирилл.